main.py:
```
import sys
from PyQt5.QtWidgets import QApplication, QMainWindow, QTreeView, QFileSystemModel, QVBoxLayout, QWidget, QLineEdit, QPushButton, QMessageBox, QHBoxLayout, QLabel, QFrame, QProgressBar
from PyQt5.QtCore import QDir, QSize, QTimer
from PyQt5.QtGui import QStandardItemModel, QStandardItem, QIcon
import ftplib
import os
import socket
import sqlite3
from serv_FM import FTPFileModel
from Actions import Actions, Logger

ftplib.DEBUGLEVEL = 0


class FTPClient(QMainWindow):
    def __init__(self):
        super().__init__()
        self.ftp = None
        self.current_directory = '/'
        self.local_directory = QDir.homePath()
        self.database = sqlite3.connect("main_data.db")
        self.ftp_file_model = None
        self.upload_thread = None
        self.is_double_click_processing = False
        self.user = None
        self.host = None
        self.passw = None
        self.initUI()

    def initUI(self):
        self.setWindowTitle('FTPWidget')
        self.setGeometry(400, 100, 1300, 800)

        # Создание виджетов
        # Верхняя панель подключения
        self.host_input = QLineEdit()
        self.host_input.setPlaceholderText('IP хоста')
        self.username_input = QLineEdit()
        self.username_input.setPlaceholderText('Имя пользователя')
        self.password_input = QLineEdit()
        self.password_input.setPlaceholderText('Пароль')
        self.password_input.setEchoMode(QLineEdit.Password)
        self.port_input = QLineEdit()
        self.port_input.setPlaceholderText('Порт')

        self.highbox = QHBoxLayout()
        self.connect_button = QPushButton('Подключиться')
        self.connect_button.clicked.connect(self.connect_to_ftp)
        self.disconnect_button = QPushButton('Отключиться')
        self.disconnect_button.clicked.connect(self.ftp_disconnect)
        self.highbox.addWidget(self.connect_button)
        self.highbox.addWidget(self.disconnect_button)

        # Кнопка назад на сервере
        self.back_button = QPushButton()
        self.back_button.clicked.connect(self.go_back)
        back_button_icon = QIcon('pictures/back.png')
        self.back_button.setIcon(back_button_icon)
        self.back_button.setIconSize(QSize(20, 20))
        self.back_button.setFixedSize(25, 25)

        # Кнопка назад на локальном компьютере
        self.back_button_loc = QPushButton()
        self.back_button_loc.clicked.connect(self.go_back_loc)
        self.back_button_loc.setIcon(back_button_icon)
        self.back_button_loc.setIconSize(QSize(20, 20))
        self.back_button_loc.setFixedSize(25, 25)

        # Поля для отображения директорий
        self.local_location = QLineEdit(self.local_directory)
        self.local_location.setReadOnly(True)
        self.serv_location = QLineEdit()
        self.serv_location.setReadOnly(True)
        self.local_label = QLabel("Локальный компьютер:")
        self.serv_label = QLabel("FTP Сервер:")

        # Дерево файлов локального компьютера
        self.file_tree = QTreeView()
        self.file_model = QFileSystemModel()
        self.file_tree.setModel(self.file_model)
        self.file_tree.setRootIndex(self.file_model.setRootPath(QDir.homePath()))

        # Дерево файлов сервера
        self.serv_file_tree = QTreeView()

        # Создаем контейнеры для кнопок
        local_buttons_container = QWidget()
        local_buttons_layout = QHBoxLayout(local_buttons_container)

        server_buttons_container = QWidget()
        server_buttons_layout = QHBoxLayout(server_buttons_container)

        # Кнопки для локального компьютера
        self.button_delete_local = QPushButton('Удалить')
        self.button_delete_local.clicked.connect(
            lambda: Actions.Delete_Loc(self, self.local_location, self.file_tree, self.file_model)())
        self.button_record = QPushButton('Записать на сервер')
        self.button_record.clicked.connect(lambda: Actions.Record(self, self.local_location, self.serv_location)())
        local_buttons_layout.addWidget(self.button_delete_local)
        local_buttons_layout.addWidget(self.button_record)

        # Кнопки для сервера
        self.button_delete_server = QPushButton('Удалить')
        self.button_delete_server.clicked.connect(lambda: Actions.Delete_Serv(self, self.serv_location, self)())
        self.button_download = QPushButton('Скачать')
        self.button_download.clicked.connect(lambda: Actions.Download(self, self.serv_location)())
        server_buttons_layout.addWidget(self.button_delete_server)
        server_buttons_layout.addWidget(self.button_download)

        # Дополнительные кнопки
        self.button_report_history = QPushButton('Отчёт истории')
        self.button_report = QPushButton('Отчёт')
        self.button_report_history.setVisible(False)
        self.button_report.setVisible(False)
        self.button_report_history.clicked.connect(self.open_history_report)
        self.button_chat = QPushButton('Чат')

        # Основной layout
        main_layout = QVBoxLayout()

        # Панель подключения
        connection_layout = QHBoxLayout()
        connection_layout.addWidget(self.host_input)
        connection_layout.addWidget(self.username_input)
        connection_layout.addWidget(self.password_input)
        connection_layout.addWidget(self.port_input)
        main_layout.addLayout(connection_layout)
        main_layout.addLayout(self.highbox)

        # Панель путей
        paths_layout = QHBoxLayout()
        paths_layout.addWidget(self.local_label)
        paths_layout.addWidget(self.local_location)
        paths_layout.addWidget(self.back_button_loc)
        paths_layout.addWidget(self.serv_label)
        paths_layout.addWidget(self.serv_location)
        paths_layout.addWidget(self.back_button)
        main_layout.addLayout(paths_layout)

        # Панель файловых деревьев
        files_layout = QHBoxLayout()
        files_layout.addWidget(self.file_tree)
        files_layout.addWidget(self.serv_file_tree)
        main_layout.addLayout(files_layout)

        # Панель кнопок действий
        actions_layout = QHBoxLayout()

        # Локальные кнопки (под левым деревом)
        local_actions = QVBoxLayout()
        local_actions.addWidget(QLabel("Действия с локальными файлами:"))
        local_actions.addWidget(local_buttons_container)

        # Серверные кнопки (под правым деревом)
        server_actions = QVBoxLayout()
        server_actions.addWidget(QLabel("Действия с файлами сервера:"))
        server_actions.addWidget(server_buttons_container)

        actions_layout.addLayout(local_actions)
        actions_layout.addLayout(server_actions)
        main_layout.addLayout(actions_layout)

        # Дополнительные кнопки
        other_buttons_layout = QHBoxLayout()
        other_buttons_layout.addWidget(self.button_report)
        other_buttons_layout.addWidget(self.button_report_history)
        other_buttons_layout.addWidget(self.button_chat)
        main_layout.addLayout(other_buttons_layout)

        # Установка главного виджета
        central_widget = QWidget()
        central_widget.setLayout(main_layout)
        self.setCentralWidget(central_widget)

        # Подключение сигналов
        self.serv_file_tree.doubleClicked.connect(self.item_double_clicked_in_serv)
        self.file_tree.doubleClicked.connect(self.item_double_clicked_in_local)

    def connect_to_ftp(self):
        admin_data = []
        try:
            with self.database as connection:
                cursor = connection.cursor()
                cursor.execute("SELECT ad_serv_host, admin_log, admin_psw FROM admin")
                rows = cursor.fetchall()
                for row in rows:
                    hosts = row[0]
                    logins = row[1]
                    passwords = row[2]
                    full_data = [hosts, logins, passwords]
                    admin_data.append(full_data)
        except sqlite3.Error as e:
            QMessageBox.critical(self, "Ошибка БД", f"Ошибка при чтении данных из БД admin: {e}")
            return

        self.host = self.host_input.text()
        self.user = self.username_input.text()
        self.passw = self.password_input.text()
        port_text = self.port_input.text()
        is_admin = False

        try:
            # Перед подключением закрываем старое соединение
            if self.ftp:
                self.ftp_disconnect()

            for value_host in admin_data:
                if self.host == value_host[0] and self.user == value_host[1] and self.passw == value_host[2]:
                    is_admin = True
                    break

            try:
                port = int(port_text) if port_text else 21
            except ValueError:
                QMessageBox.critical(self, "Ошибка", "Неверный формат порта.  Используется порт 21 по умолчанию.")
                port = 21

            self.ftp = ftplib.FTP(timeout=30)
            self.ftp.set_pasv(True)
            self.ftp.connect(self.host, port, timeout=30)
            self.ftp.login(user=self.user, passwd=self.passw)
            print(f"Пассивный режим включён: {self.ftp.passiveserver}")
            QMessageBox.information(self, 'Подключение к серверу', 'Успешное подключение!')

            self.ftp.sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
            self.ftp.sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)
            self.ftp.sock.setsockopt(socket.SOL_SOCKET, socket.SO_SNDBUF, 65536)
            self.ftp.sock.setsockopt(socket.SOL_SOCKET, socket.SO_RCVBUF, 65536)

            self.button_report_history.setVisible(True)
            self.button_report.setVisible(True)
            self.update()

            try:
                Logger.loging(self.user,"Подключение",  f"Сервер: {self.host}")
            except Exception as e:
                print(f'Не удалось записать в лог: {str(e)}')

            self.ftp_file_model = FTPFileModel(self, self.current_directory, self.ftp)
            self.serv_file_tree.setModel(self.ftp_file_model)
            self.update_server_tree()
            self.serv_location.setText(self.current_directory)

        except ftplib.all_errors as e:
            QMessageBox.critical(self, 'Ошибка FTP', f'Ошибка FTP: {str(e)}')
        except Exception as e:
            QMessageBox.critical(self, 'Ошибка', f'Не удалось подключиться к FTP-серверу: {str(e)}')

    def ftp_disconnect(self):
        if self.ftp:
            Logger.loging(self.user, "Отключение", "От сервера FTP")
            try:
                self.ftp.quit()
                self.ftp = None
                QMessageBox.information(self, 'Отключение', 'Отключение произошло успешно')
            except ftplib.all_errors as e:
                QMessageBox.warning(self, 'Ошибка отключения', f'Ошибка при отключении: {str(e)}')
            finally:
                self.current_directory = '/'
                self.serv_location.setText('')
                self.serv_file_tree.setModel(None)
                self.host_input.setText('')
                self.username_input.setText('')
                self.port_input.setText('')
                self.password_input.setText('')
                self.button_report_history.setVisible(False)
                self.button_report.setVisible(False)

    def update_server_tree(self):
        """Полное обновление дерева сервера"""
        if not self.ftp or not self.ftp_file_model:
            return

        try:
            current_path = self.ftp.pwd()
            self.ftp_file_model.root_path = current_path
            self.ftp_file_model.load_data()
            self.serv_location.setText(current_path)
            self.serv_file_tree.viewport().update()
        except Exception as e:
            QMessageBox.warning(self, 'Ошибка', f'Ошибка обновления: {str(e)}')

    def force_refresh_server_tree(self):
        """Принудительное обновление с задержкой"""
        QTimer.singleShot(100, self.update_server_tree)

    def setup_upload_thread(self, thread):
        """Настройка обработчиков для потока загрузки"""
        thread.finished.connect(lambda msg: QMessageBox.information(self, "Успех", msg))
        thread.error.connect(lambda err: QMessageBox.critical(self, "Ошибка", err))
        thread.update_needed.connect(self.force_refresh_server_tree)
        self.upload_thread = thread

    def _load_ftp_data(self):
        if self.ftp and self.ftp_file_model:
            self.ftp_file_model.root_path = self.current_directory
            self.ftp_file_model.load_data()
            self.serv_file_tree.viewport().update()

    def item_double_clicked_in_local(self, index):
        path = self.file_model.filePath(index)

        if os.path.isfile(path):
            self.local_location.setText(path)
            self.local_directory = os.path.dirname(path)
        elif os.path.isdir(path):
            self.local_directory = path
            self.local_location.setText(path)
        else:
            QMessageBox.warning(self, "Ошибка", "Неизвестный тип файла.")

        self.file_tree.setRootIndex(self.file_model.setRootPath(self.local_directory))

    def item_double_clicked_in_serv(self, index):
        if self.is_double_click_processing:
            return

        self.is_double_click_processing = True
        
        try:
            if not self.ftp or not self.ftp_file_model or not index.isValid():
                return

            item = self.ftp_file_model.file_list[index.row()]
            item_name = item['name']
            is_dir = item['is_dir']

            if item_name == '..':
                self.go_back()
                return

            if is_dir:
                new_path = os.path.join(self.current_directory, item_name).replace('\\', '/')
                try:
                    # Сохраняем текущий путь перед изменением
                    old_path = self.ftp.pwd()
                    
                    # Переходим в новую директорию
                    self.ftp.cwd(new_path)
                    self.current_directory = new_path
                    
                    # Полностью перезагружаем модель
                    self.ftp_file_model.root_path = new_path
                    self.ftp_file_model.load_data()
                    
                    # Обновляем интерфейс
                    self.serv_location.setText(new_path)
                    self.serv_file_tree.viewport().update()
                    
                except ftplib.error_perm as e:
                    QMessageBox.warning(self, 'Ошибка', f'Нет доступа: {e}')
                    # Восстанавливаем предыдущий путь
                    try:
                        self.ftp.cwd(old_path)
                    except:
                        pass
            else:
                full_path = os.path.join(self.current_directory, item_name).replace('\\', '/')
                self.serv_location.setText(full_path)
                
        except Exception as e:
            QMessageBox.critical(self, 'Ошибка', f'Ошибка при обработке: {str(e)}')
        finally:
            self.is_double_click_processing = False

    def reset_double_click_flag(self):
        self.is_double_click_processing = False

    def go_back_loc(self):
        current_path = self.local_directory
        parent_path = os.path.dirname(current_path)

        if parent_path:
            self.local_directory = parent_path
            self.local_location.setText(parent_path)
            self.file_tree.setRootIndex(self.file_model.setRootPath(parent_path))

    def go_back(self):
        if self.current_directory != '/':
            parent_directory = '/'.join(self.current_directory.split('/')[:-1]) or '/'
            try:
                self.ftp.cwd(parent_directory)
                self.current_directory = self.ftp.pwd()
                self.update_server_tree()
                self.serv_location.setText(self.current_directory)
            except ftplib.error_perm as e:
                QMessageBox.warning(self, 'Ошибка', f'Нет доступа к родительской директории: {str(e)}')
            except Exception as e:
                QMessageBox.critical(self, 'Ошибка', f'Не удалось перейти в родительскую директорию: {str(e)}')
        else:
            QMessageBox.information(self, 'Информация', 'Вы уже находитесь в корневой директории.')

    def closeEvent(self, event):
        """Обработка закрытия окна"""
        if self.ftp:
            self.ftp_disconnect()
        if hasattr(self, 'upload_thread') and self.upload_thread and self.upload_thread.isRunning():
            self.upload_thread.quit()
            self.upload_thread.wait()
        event.accept()

    def open_history_report(self):
        try: 
            history_file = "history_adv.xls"
            if os.path.exists(history_file):
                os.startfile(history_file)
            else:
                QMessageBox.information(self, "Информация", "Файл с историей действий не создан ")
        except Exception as e: 
            QMessageBox.critical(self, "Ошибка", f"Не удалось открыть файл истории: {str(e)}")


if __name__ == '__main__':
    app = QApplication(sys.argv)
    client = FTPClient()
    client.show()
    sys.exit(app.exec_())

```
Actions.py:
```
import os
import ftplib
from PyQt5.QtWidgets import QMessageBox, QInputDialog, QApplication
import shutil
from PyQt5.QtCore import QThread, pyqtSignal
import socket
import xlrd
import xlwt
from datetime import datetime
import os



class FTPUploadThread(QThread):
    finished = pyqtSignal(str)
    error = pyqtSignal(str)
    update_needed = pyqtSignal()

    def __init__(self, main_window, local_filepath, server_filepath):
        super().__init__()
        self.main_window = main_window
        self.local_filepath = local_filepath
        self.server_filepath = server_filepath
        self.block_size = 32768
        self.timeout = 30
        self.ftp = None  # Добавляем ссылку на объект FTP

    def run(self):
        try:
            self.ftp = self.main_window.ftp
            if not self.ftp or not self.ftp.sock:
                self.error.emit("Нет соединения с FTP")
                return

            # Явно устанавливаем бинарный режим
            self.ftp.voidcmd('TYPE I')
            
            with open(self.local_filepath, 'rb') as f:
                # Устанавливаем таймауты
                self.ftp.sock.settimeout(30)
                
                # Загружаем файл
                self.ftp.storbinary(f'STOR {self.server_filepath}', f, blocksize=32768)
                
                # Явно ждём завершения
                response = self.ftp.getresp()
                if response.startswith(('226', '250')):
                    self.finished.emit(f"Файл загружен: {self.server_filepath}")
                    # Даём время серверу обработать
                    QThread.msleep(200)
                    self.update_needed.emit()
                else:
                    self.error.emit(f"Ошибка сервера: {response}")
                    
        except Exception as e:
            self.error.emit(f"Ошибка загрузки: {str(e)}")

        except socket.timeout:
            self.error.emit("Таймаут операции")
        except ftplib.Error as e:
            self.error.emit(f"FTP ошибка: {str(e)}")
        except Exception as e:
            self.error.emit(f"Неизвестная ошибка: {str(e)}")


class Actions:

    @staticmethod
    def Download(main_window, serv_location):
        def download_action():
            filename = serv_location.text()
            Logger.loging("Скачивание", f"Файл: {filename}")

            if not filename:
                QMessageBox.warning(main_window, "Внимание", "Не выбран файл для скачивания.")
                return

            filepath_on_server = filename  # Используем уже полный путь
            file_name = os.path.basename(filename)

            if not file_name:
                QMessageBox.warning(main_window, "Внимание", "Не удалось получить имя файла.")
                return

            local_filepath = os.path.join(main_window.local_directory, file_name)

            try:
                with open(local_filepath, 'wb') as local_file:
                    main_window.ftp.retrbinary(f'RETR {filepath_on_server}', local_file.write)
                QMessageBox.information(main_window, "Успех",
                                          f"Файл '{file_name}' успешно скачан в '{main_window.local_directory}'.")
                main_window.update_server_tree()

            except ftplib.error_perm as e:
                QMessageBox.critical(main_window, 'Ошибка скачивания', f'Ошибка доступа к файлу: {str(e)}')
            except ftplib.error_temp as e:
                QMessageBox.critical(main_window, 'Ошибка скачивания',
                                       f'Временная ошибка при скачивании файла: {str(e)}')
            except ftplib.error_proto as e:
                QMessageBox.critical(main_window, 'Ошибка скачивания',
                                       f'Протокольная ошибка при скачивании файла: {str(e)}')
            except Exception as e:
                QMessageBox.critical(main_window, 'Ошибка', f'Не удалось скачать файл: {str(e)}')

        return download_action

    @staticmethod
    def Record(main_window, local_location, server_location):
        def recording():
            local_filepath = local_location.text()
            server_filepath = server_location.text()

            if not local_filepath:
                QMessageBox.warning(main_window, "Внимание", "Не выбран локальный файл для записи.")
                return

            default_filename = os.path.basename(local_filepath)

            file_name, ok = QInputDialog.getText(main_window, "Имя файла","Введите имя файла для сохранения на сервере:",text=default_filename)
            if not ok or not file_name:
                return

            Logger.loging(main_window.user, "Загрузка на сервер", f"Локальный файл. {file_name} загружен в {server_filepath}")

            server_filepath = os.path.join(main_window.current_directory, file_name).replace('\\', '/')

            # Создаем и настраиваем поток
            upload_thread = FTPUploadThread(main_window, local_filepath, server_filepath)
            main_window.setup_upload_thread(upload_thread)
            upload_thread.start()

        return recording

    @staticmethod
    def Delete_Serv(main_window, serv_location, parent):
        def delete_action_serv():
            filename = serv_location.text()
            Logger.loging(main_window.user,"Удаление с сервера", f"Файл: {filename}")

            if not filename:
                QMessageBox.warning(main_window, "Внимание", "Не выбран файл для удаления на сервере.")
                return

            filepath_on_server = filename  # Используем полный путь

            try:
                main_window.ftp.delete(filepath_on_server)
                QMessageBox.information(main_window, "Успех",
                                          f"Файл '{os.path.basename(filepath_on_server)}' успешно удален с сервера.")
                main_window.update_server_tree()
                serv_location.setText(main_window.current_directory)

            except ftplib.error_perm as e:
                QMessageBox.critical(main_window, 'Ошибка удаления', f'Ошибка доступа при удалении файла: {str(e)}')
            except ftplib.error_temp as e:
                QMessageBox.critical(main_window, 'Ошибка удаления', f'Временная ошибка при удалении файла: {str(e)}')
            except ftplib.error_proto as e:
                QMessageBox.critical(main_window, 'Ошибка удаления', f'Протокольная ошибка при удалении файла: {str(e)}')
            except Exception as e:
                QMessageBox.critical(main_window, 'Ошибка', f'Не удалось удалить файл: {str(e)}')

        return delete_action_serv

    @staticmethod
    def Delete_Loc(main_window, local_location, file_tree, file_model):
        def delete_action_loc():
            filepath_on_local = local_location.text()
            Logger.loging(main_window.user,"Удаление локального файла", f"Путь: {os.path.basename(filepath_on_local)}")

            if not filepath_on_local:
                QMessageBox.warning(main_window, "Внимание", 'Не выбран путь для удаления на локальной машине.')
                return

            if not os.path.exists(filepath_on_local):
                QMessageBox.warning(main_window, 'Ошибка', f"Файл не существует: {filepath_on_local}")
                return

            try:
                if os.path.isfile(filepath_on_local):
                    os.remove(filepath_on_local)
                    QMessageBox.information(main_window, "Успех",
                                              f"Файл '{os.path.basename(filepath_on_local)}', успешно удалён с локальной машины.")
                elif os.path.isdir(filepath_on_local):
                    shutil.rmtree(filepath_on_local)
                    QMessageBox.information(main_window, 'Успех',
                                              f"Директория '{filepath_on_local}' успешно удалёна с локальной машины.")
                else:
                    QMessageBox.warning(main_window, "Ошибка", "Неизвестный тип объекта для удаления.")
                    return

                file_tree.setRootIndex(file_model.setRootPath(os.path.dirname(filepath_on_local)))

            except PermissionError as e:
                QMessageBox.critical(main_window, 'Ошибка прав', f'Нет прав для удаления: {str(e)}')
            except OSError as e:
                QMessageBox.critical(main_window, 'Ошибка системы', f'Ошибка при удалении: {str(e)}')
            except Exception as e:
                QMessageBox.critical(main_window, 'Ошибка', f'Не удалось удалить: {str(e)}')

        return delete_action_loc


class Logger:
    @staticmethod
    def loging(username, action, details, filename='history_adv.xls'):
        try:
            # Создаем Excel файла
            workbook = xlwt.Workbook()
            sheet = workbook.add_sheet("History")
            
            # Заголовки
            headers = ["Дата и время", "Пользователь", "Действие", "Детали"]
            for col, header in enumerate(headers):
                sheet.write(0, col, header)
            
            # Проверяем существование файла и читаем старые данные
            if os.path.exists(filename):
                try:
                    old_workbook = xlrd.open_workbook(filename)
                    old_sheet = old_workbook.sheet_by_index(0)
                    
                    for row in range(1, old_sheet.nrows):
                        for col in range(old_sheet.ncols):
                            sheet.write(row, col, old_sheet.cell_value(row, col))
                    
                    next_row = old_sheet.nrows
                except:
                    # Если ошибка чтения, начинаем новую историю
                    next_row = 1
            else:
                next_row = 1
            
            # Добавляем новую запись (4 колонки)
            sheet.write(next_row, 0, datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            sheet.write(next_row, 1, username)
            sheet.write(next_row, 2, action)
            sheet.write(next_row, 3, details)
            
            workbook.save(filename)
            
        except Exception as e:
            print(f"Ошибка при логировании: {str(e)}")
            # Резервное логирование в текстовый файл
            try:
                with open('history_fallback.txt', 'a', encoding='utf-8') as f:
                    f.write(f"{datetime.now()}|{username}|{action}|{details}\n")
            except Exception as e:
                print(f"Ошибка резервного логирования: {str(e)}")
```
serv_FM.py:
```
from PyQt5.QtCore import QAbstractItemModel, QModelIndex, Qt, QVariant
from PyQt5.QtGui import QIcon
import ftplib
import os


class FTPFileModel(QAbstractItemModel):
    def __init__(self, ftp_client, root_path="/", ftp=None):
        super().__init__()
        self.ftp_client = ftp_client
        self.root_path = root_path
        self.file_list = []
        self.columns = ["Имя", "Размер", "Дата изменения", "Тип"]
        self.ftp = ftp

        self.folder_icon = QIcon("pictures/folder.png")
        self.config_icon = QIcon("pictures/config.png")
        self.excel_icon = QIcon("pictures/excel.png")
        self.newfile_icon = QIcon("pictures/Newfile.png")
        self.png_icon = QIcon("pictures/png.png")
        self.txt_icon = QIcon("pictures/txt.png")
        self.word_icon = QIcon("pictures/word.png")

        self.load_data()

    def load_data(self):
        if self.ftp is None:
            return

        self.beginResetModel()
        self.file_list = []
        
        try:
            # Получаем текущую директорию
            current_dir = self.ftp.pwd()
            
            # Пытаемся перейти в целевую директорию
            try:
                if self.root_path != current_dir:
                    self.ftp.cwd(self.root_path)
            except ftplib.error_perm as e:
                print(f"Не удалось перейти в {self.root_path}: {e}")
                self.endResetModel()
                return

            lines = []
            try:
                self.ftp.retrlines('LIST', lambda x: lines.append(x))
            except ftplib.error_perm as e:
                print(f"Ошибка LIST: {e}")
                self.endResetModel()
                return

            for line in lines:
                try:
                    self.process_ftp_line(line)
                except Exception as e:
                    print(f"Ошибка обработки строки: {e}")
                    continue

            # Сортировка: сначала директории, потом файлы
            self.file_list.sort(key=lambda x: (not x['is_dir'], x['name'].lower()))

            # Добавляем ".." если не в корне
            if self.root_path != '/':
                self.file_list.insert(0, {
                    'name': '..',
                    'size': 0,
                    'last_modified': '',
                    'is_dir': True
                })

        except Exception as e:
            print(f"Критическая ошибка при загрузке данных: {e}")
        finally:
            self.endResetModel()


    def process_ftp_line(self, line):
        parts = line.split()
        if len(parts) < 6:
            raise ValueError(f"Неверный формат строки LIST: {line}")

        is_dir = parts[0].startswith('d')
        try:
            size = int(parts[4]) if not is_dir else 0
        except (IndexError, ValueError):
            size = 0

        last_modified = ' '.join(parts[5:8]) if len(parts) >= 8 else ''
        name = ' '.join(parts[8:]) if len(parts) > 8 else parts[-1]

        self.file_list.append({
            'name': name,
            'size': size,
            'last_modified': last_modified,
            'is_dir': is_dir
        })

    def rowCount(self, parent=QModelIndex()):
        if parent.isValid():
            return 0
        return len(self.file_list)

    def columnCount(self, parent=QModelIndex()):
        return len(self.columns)

    def data(self, index, role=Qt.DisplayRole):
        if not index.isValid():
            return QVariant()

        row = index.row()
        if row < 0 or row >= len(self.file_list):
            return QVariant()

        file_info = self.file_list[row]
        name = file_info['name']
        is_dir = file_info['is_dir']

        if role == Qt.DisplayRole:
            col = index.column()
            if col == 0:
                return name
            elif col == 1:
                return "<DIR>" if is_dir else f"{file_info['size']} bytes"
            elif col == 2:
                return file_info['last_modified']
            elif col == 3:
                return "Directory" if is_dir else "File"
        elif role == Qt.DecorationRole and index.column() == 0:
            if name == '..':
                return QIcon('pictures/back.png')
            if is_dir:
                return self.folder_icon

            ext = os.path.splitext(name)[1].lower()
            if ext in (".dll", ".ini"):
                return self.config_icon
            elif ext == ".xlsx":
                return self.excel_icon
            elif ext == ".png":
                return self.png_icon
            elif ext == ".txt":
                return self.txt_icon
            elif ext in (".doc", ".docx"):
                return self.word_icon
            return self.newfile_icon

        return QVariant()

    def headerData(self, section, orientation, role=Qt.DisplayRole):
        if orientation == Qt.Horizontal and role == Qt.DisplayRole:
            return self.columns[section]
        return QVariant()

    def index(self, row, column, parent=QModelIndex()):
        if not self.hasIndex(row, column, parent):
            return QModelIndex()
        return self.createIndex(row, column, None)

    def parent(self, index):
        return QModelIndex()

    def change_root(self, path):
        self.root_path = path
        self.load_data()

    def refresh(self):
        """Принудительное обновление списка файлов"""
        self.load_data()

```
